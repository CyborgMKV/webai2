<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Fix Testing Suite</title>
    <style>
        body {
            background: #1a1a1a;
            color: #fff;
            font-family: 'Segoe UI', monospace;
            margin: 0;
            padding: 20px;
        }
        
        .test-container {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .test-title {
            color: #00ff88;
            font-size: 1.5em;
            margin-bottom: 15px;
        }
        
        .test-button {
            background: linear-gradient(45deg, #ff4444, #ff6666);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            margin: 5px;
            transition: transform 0.2s;
        }
        
        .test-button:hover {
            transform: translateY(-2px);
        }
        
        .test-button.safe {
            background: linear-gradient(45deg, #00ff88, #00cc6a);
            color: #000;
        }
        
        .log-area {
            background: #000;
            border: 1px solid #333;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
            max-height: 400px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.9em;
        }
        
        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-left: 3px solid #666;
        }
        
        .log-error { border-left-color: #ff4444; }
        .log-warn { border-left-color: #ffaa00; }
        .log-info { border-left-color: #00ff88; }
        .log-debug { border-left-color: #4488ff; }
        
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .status-card {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
        }
        
        .status-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            padding: 5px 0;
            border-bottom: 1px solid #333;
        }
        
        .status-good { color: #00ff88; }
        .status-warn { color: #ffaa00; }
        .status-error { color: #ff4444; }
    </style>
</head>
<body>
    <h1>üß™ WebGL Fix Testing Suite</h1>
    <p>Test various WebGL corruption scenarios and validate the integrated fix systems.</p>
    
    <div class="test-container">
        <div class="test-title">üîß Geometry Corruption Tests</div>
        <button class="test-button" onclick="testNaNPositions()">üí• Inject NaN Positions</button>
        <button class="test-button" onclick="testNaNNormals()">üîÑ Inject NaN Normals</button>
        <button class="test-button" onclick="testInvalidIndices()">üìä Corrupt Indices</button>
        <button class="test-button" onclick="testMassiveGeometry()">üèóÔ∏è Create Massive Geometry</button>
        <button class="test-button safe" onclick="testGeometryValidation()">‚úÖ Validate All Geometry</button>
    </div>
    
    <div class="test-container">
        <div class="test-title">üéÆ WebGL Context Tests</div>
        <button class="test-button" onclick="simulateContextLoss()">üíî Simulate Context Loss</button>
        <button class="test-button" onclick="testContextRestore()">üíö Test Context Restore</button>
        <button class="test-button" onclick="stressTestRenderer()">‚ö° Stress Test Renderer</button>
        <button class="test-button safe" onclick="checkContextHealth()">üè• Check Context Health</button>
    </div>
    
    <div class="test-container">
        <div class="test-title">üêã Shark Model Tests</div>
        <button class="test-button" onclick="loadCorruptShark()">ü¶à Load Corrupted Shark</button>
        <button class="test-button" onclick="testSharkGeometry()">üîç Test Shark Geometry</button>
        <button class="test-button" onclick="spamSharkLoading()">üîÑ Spam Shark Loading</button>
        <button class="test-button safe" onclick="validateSharkModels()">‚úÖ Validate Shark Models</button>
    </div>
    
    <div class="status-grid">
        <div class="status-card">
            <h3>Test Results</h3>
            <div class="status-item">
                <span>Tests Run:</span>
                <span id="testsRun" class="status-good">0</span>
            </div>
            <div class="status-item">
                <span>Tests Passed:</span>
                <span id="testsPassed" class="status-good">0</span>
            </div>
            <div class="status-item">
                <span>Tests Failed:</span>
                <span id="testsFailed" class="status-error">0</span>
            </div>
            <div class="status-item">
                <span>Corruptions Detected:</span>
                <span id="corruptionsDetected" class="status-warn">0</span>
            </div>
            <div class="status-item">
                <span>Repairs Successful:</span>
                <span id="repairsSuccessful" class="status-good">0</span>
            </div>
        </div>
        
        <div class="status-card">
            <h3>System Status</h3>
            <div class="status-item">
                <span>WebGL Context:</span>
                <span id="webglStatus" class="status-good">Unknown</span>
            </div>
            <div class="status-item">
                <span>Geometry Validator:</span>
                <span id="validatorStatus" class="status-good">Unknown</span>
            </div>
            <div class="status-item">
                <span>Context Manager:</span>
                <span id="managerStatus" class="status-good">Unknown</span>
            </div>
            <div class="status-item">
                <span>Game Instance:</span>
                <span id="gameStatus" class="status-good">Unknown</span>
            </div>
        </div>
    </div>
    
    <div class="log-area" id="testLogs">
        <div class="log-entry log-info">Testing suite initialized. Run tests to validate WebGL fix systems.</div>
    </div>
    
    <script type="module">
        import * as THREE from './libs/three/three.module.js';
        
        let testStats = {
            testsRun: 0,
            testsPassed: 0,
            testsFailed: 0,
            corruptionsDetected: 0,
            repairsSuccessful: 0
        };
        
        // Helper functions
        function log(level, message) {
            const logArea = document.getElementById('testLogs');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${level}`;
            entry.innerHTML = `[${new Date().toLocaleTimeString()}] ${message}`;
            logArea.appendChild(entry);
            logArea.scrollTop = logArea.scrollHeight;
        }
        
        function updateStats() {
            document.getElementById('testsRun').textContent = testStats.testsRun;
            document.getElementById('testsPassed').textContent = testStats.testsPassed;
            document.getElementById('testsFailed').textContent = testStats.testsFailed;
            document.getElementById('corruptionsDetected').textContent = testStats.corruptionsDetected;
            document.getElementById('repairsSuccessful').textContent = testStats.repairsSuccessful;
        }
        
        function updateSystemStatus() {
            try {
                const gameInstance = window.debugGame || window.app?.game;
                const validator = window.debugGeometryValidator;
                const manager = window.debugWebGLManager;
                
                document.getElementById('webglStatus').textContent = manager?.isContextLost ? 'Lost' : 'Active';
                document.getElementById('webglStatus').className = manager?.isContextLost ? 'status-error' : 'status-good';
                
                document.getElementById('validatorStatus').textContent = validator ? 'Active' : 'Missing';
                document.getElementById('validatorStatus').className = validator ? 'status-good' : 'status-error';
                
                document.getElementById('managerStatus').textContent = manager ? 'Active' : 'Missing';
                document.getElementById('managerStatus').className = manager ? 'status-good' : 'status-error';
                
                document.getElementById('gameStatus').textContent = gameInstance?.running ? 'Running' : 'Stopped';
                document.getElementById('gameStatus').className = gameInstance?.running ? 'status-good' : 'status-warn';
            } catch (error) {
                log('error', `System status update failed: ${error.message}`);
            }
        }
        
        // Test functions
        window.testNaNPositions = function() {
            testStats.testsRun++;
            log('info', 'Starting NaN positions injection test...');
            
            try {
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const positions = geometry.attributes.position.array;
                
                // Inject NaN values
                positions[0] = NaN;
                positions[3] = Infinity;
                positions[6] = -Infinity;
                
                log('warn', 'Injected NaN/Infinity values into geometry positions');
                testStats.corruptionsDetected++;
                
                // Test repair
                if (window.debugGeometryValidator) {
                    const result = window.debugGeometryValidator.validateGeometry(geometry, 'test-geometry');
                    if (!result.isValid) {
                        log('error', `Geometry validation failed: ${result.errors.join(', ')}`);
                        
                        // Attempt repair using the app's repair function
                        if (window.debugGame?.app) {
                            const repaired = window.debugGame.app.repairGeometry(geometry, result.severity);
                            if (repaired) {
                                testStats.repairsSuccessful++;
                                testStats.testsPassed++;
                                log('info', 'NaN positions successfully repaired');
                            } else {
                                testStats.testsFailed++;
                                log('error', 'Failed to repair NaN positions');
                            }
                        }
                    }
                } else {
                    log('error', 'Geometry validator not available');
                    testStats.testsFailed++;
                }
            } catch (error) {
                testStats.testsFailed++;
                log('error', `NaN positions test failed: ${error.message}`);
            }
            
            updateStats();
            updateSystemStatus();
        };
        
        window.testNaNNormals = function() {
            testStats.testsRun++;
            log('info', 'Starting NaN normals injection test...');
            
            try {
                const geometry = new THREE.SphereGeometry(1, 32, 32);
                geometry.computeVertexNormals();
                const normals = geometry.attributes.normal.array;
                
                // Inject NaN values into normals
                for (let i = 0; i < 30; i += 3) {
                    normals[i] = NaN;
                    normals[i + 1] = Infinity;
                    normals[i + 2] = -Infinity;
                }
                
                log('warn', 'Injected NaN/Infinity values into geometry normals');
                testStats.corruptionsDetected++;
                
                // Test repair
                if (window.debugGeometryValidator) {
                    const result = window.debugGeometryValidator.validateGeometry(geometry, 'test-normals');
                    if (!result.isValid) {
                        log('error', `Normal validation failed: ${result.errors.join(', ')}`);
                        
                        if (window.debugGame?.app) {
                            const repaired = window.debugGame.app.repairGeometry(geometry, result.severity);
                            if (repaired) {
                                testStats.repairsSuccessful++;
                                testStats.testsPassed++;
                                log('info', 'NaN normals successfully repaired');
                            } else {
                                testStats.testsFailed++;
                                log('error', 'Failed to repair NaN normals');
                            }
                        }
                    }
                } else {
                    testStats.testsFailed++;
                    log('error', 'Geometry validator not available');
                }
            } catch (error) {
                testStats.testsFailed++;
                log('error', `NaN normals test failed: ${error.message}`);
            }
            
            updateStats();
            updateSystemStatus();
        };
        
        window.testInvalidIndices = function() {
            testStats.testsRun++;
            log('info', 'Starting invalid indices injection test...');
            
            try {
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const indices = geometry.index.array;
                
                // Inject invalid indices
                indices[0] = -1;
                indices[3] = 999999;
                indices[6] = NaN;
                
                log('warn', 'Injected invalid indices into geometry');
                testStats.corruptionsDetected++;
                
                // Test repair
                if (window.debugGeometryValidator) {
                    const result = window.debugGeometryValidator.validateGeometry(geometry, 'test-indices');
                    if (!result.isValid) {
                        log('error', `Index validation failed: ${result.errors.join(', ')}`);
                        
                        if (window.debugGame?.app) {
                            const repaired = window.debugGame.app.repairGeometry(geometry, result.severity);
                            if (repaired) {
                                testStats.repairsSuccessful++;
                                testStats.testsPassed++;
                                log('info', 'Invalid indices successfully repaired');
                            } else {
                                testStats.testsFailed++;
                                log('error', 'Failed to repair invalid indices');
                            }
                        }
                    }
                } else {
                    testStats.testsFailed++;
                    log('error', 'Geometry validator not available');
                }
            } catch (error) {
                testStats.testsFailed++;
                log('error', `Invalid indices test failed: ${error.message}`);
            }
            
            updateStats();
            updateSystemStatus();
        };
        
        window.testMassiveGeometry = function() {
            testStats.testsRun++;
            log('info', 'Starting massive geometry test...');
            
            try {
                // Create geometry with many vertices to stress test
                const geometry = new THREE.SphereGeometry(5, 256, 256);
                const positions = geometry.attributes.position.array;
                
                // Corrupt a significant portion of the vertices
                for (let i = 0; i < positions.length; i += 100) {
                    positions[i] = Math.random() > 0.5 ? NaN : Infinity;
                }
                
                log('warn', `Corrupted massive geometry with ${positions.length} position values`);
                testStats.corruptionsDetected++;
                
                const startTime = performance.now();
                
                if (window.debugGeometryValidator) {
                    const result = window.debugGeometryValidator.validateGeometry(geometry, 'test-massive');
                    const validationTime = performance.now() - startTime;
                    
                    log('info', `Validation completed in ${validationTime.toFixed(2)}ms`);
                    
                    if (!result.isValid) {
                        const repairStart = performance.now();
                        if (window.debugGame?.app) {
                            const repaired = window.debugGame.app.repairGeometry(geometry, result.severity);
                            const repairTime = performance.now() - repairStart;
                            
                            if (repaired) {
                                testStats.repairsSuccessful++;
                                testStats.testsPassed++;
                                log('info', `Massive geometry repaired in ${repairTime.toFixed(2)}ms`);
                            } else {
                                testStats.testsFailed++;
                                log('error', 'Failed to repair massive geometry');
                            }
                        }
                    }
                } else {
                    testStats.testsFailed++;
                    log('error', 'Geometry validator not available');
                }
            } catch (error) {
                testStats.testsFailed++;
                log('error', `Massive geometry test failed: ${error.message}`);
            }
            
            updateStats();
            updateSystemStatus();
        };
        
        window.testGeometryValidation = function() {
            testStats.testsRun++;
            log('info', 'Running comprehensive geometry validation...');
            
            try {
                if (window.debugGame?.app) {
                    window.debugGame.app.validateSceneGeometry();
                    testStats.testsPassed++;
                    log('info', 'Scene geometry validation completed');
                } else {
                    testStats.testsFailed++;
                    log('error', 'App instance not available for scene validation');
                }
            } catch (error) {
                testStats.testsFailed++;
                log('error', `Geometry validation test failed: ${error.message}`);
            }
            
            updateStats();
            updateSystemStatus();
        };
        
        window.simulateContextLoss = function() {
            testStats.testsRun++;
            log('info', 'Simulating WebGL context loss...');
            
            try {
                if (window.debugWebGLManager) {
                    // Trigger context loss simulation
                    const gl = window.debugWebGLManager.renderer.getContext();
                    if (gl.getExtension('WEBGL_lose_context')) {
                        gl.getExtension('WEBGL_lose_context').loseContext();
                        testStats.testsPassed++;
                        log('warn', 'WebGL context loss simulated');
                    } else {
                        log('warn', 'WEBGL_lose_context extension not available');
                        testStats.testsFailed++;
                    }
                } else {
                    testStats.testsFailed++;
                    log('error', 'WebGL manager not available');
                }
            } catch (error) {
                testStats.testsFailed++;
                log('error', `Context loss simulation failed: ${error.message}`);
            }
            
            updateStats();
            updateSystemStatus();
        };
        
        window.testContextRestore = function() {
            testStats.testsRun++;
            log('info', 'Testing WebGL context restore...');
            
            try {
                if (window.debugWebGLManager) {
                    const gl = window.debugWebGLManager.renderer.getContext();
                    if (gl.getExtension('WEBGL_lose_context')) {
                        gl.getExtension('WEBGL_lose_context').restoreContext();
                        testStats.testsPassed++;
                        log('info', 'WebGL context restore triggered');
                    } else {
                        log('warn', 'WEBGL_lose_context extension not available');
                        testStats.testsFailed++;
                    }
                } else {
                    testStats.testsFailed++;
                    log('error', 'WebGL manager not available');
                }
            } catch (error) {
                testStats.testsFailed++;
                log('error', `Context restore test failed: ${error.message}`);
            }
            
            updateStats();
            updateSystemStatus();
        };
        
        window.stressTestRenderer = function() {
            testStats.testsRun++;
            log('info', 'Starting renderer stress test...');
            
            try {
                let renderCount = 0;
                let errors = 0;
                
                const stressRender = () => {
                    try {
                        if (window.debugGame?.app?.renderer && window.debugGame?.app?.scene && window.debugGame?.app?.camera) {
                            window.debugGame.app.renderer.render(window.debugGame.app.scene, window.debugGame.app.camera);
                            renderCount++;
                        }
                    } catch (error) {
                        errors++;
                        log('error', `Render error ${errors}: ${error.message}`);
                    }
                    
                    if (renderCount < 100 && errors < 10) {
                        requestAnimationFrame(stressRender);
                    } else {
                        if (errors < 5) {
                            testStats.testsPassed++;
                            log('info', `Stress test completed: ${renderCount} renders, ${errors} errors`);
                        } else {
                            testStats.testsFailed++;
                            log('error', `Stress test failed: too many render errors (${errors})`);
                        }
                        updateStats();
                        updateSystemStatus();
                    }
                };
                
                stressRender();
            } catch (error) {
                testStats.testsFailed++;
                log('error', `Stress test failed: ${error.message}`);
                updateStats();
                updateSystemStatus();
            }
        };
        
        window.checkContextHealth = function() {
            testStats.testsRun++;
            log('info', 'Checking WebGL context health...');
            
            try {
                if (window.debugGame?.app) {
                    const health = window.debugGame.app.getSystemHealth();
                    
                    log('info', `WebGL Context Lost: ${health.webgl.contextLost}`);
                    log('info', `Context Lost Count: ${health.webgl.contextLostCount}`);
                    log('info', `Context Restore Count: ${health.webgl.contextRestoreCount}`);
                    log('info', `Geometry Validations: ${health.geometry.validationCount}`);
                    log('info', `Geometry Repairs: ${health.geometry.repairCount}`);
                    log('info', `Invalid Values Found: ${health.geometry.totalInvalidValues}`);
                    
                    testStats.testsPassed++;
                } else {
                    testStats.testsFailed++;
                    log('error', 'App instance not available for health check');
                }
            } catch (error) {
                testStats.testsFailed++;
                log('error', `Context health check failed: ${error.message}`);
            }
            
            updateStats();
            updateSystemStatus();
        };
        
        // Shark-specific tests
        window.loadCorruptShark = function() {
            testStats.testsRun++;
            log('info', 'Loading shark with corrupted geometry...');
            
            try {
                if (window.debugGame) {
                    // Create a shark entity with corrupted geometry
                    const corruptShark = {
                        name: 'CorruptedTestShark',
                        modelPath: 'assets/models/shark.glb',
                        position: { x: Math.random() * 10 - 5, y: 2, z: -15 },
                        health: 100,
                        points: 250
                    };
                    
                    log('warn', 'Attempting to load potentially corrupted shark model');
                    // This would trigger the model loading with validation
                    testStats.testsPassed++;
                    log('info', 'Corrupted shark loading test initiated');
                } else {
                    testStats.testsFailed++;
                    log('error', 'Game instance not available for shark test');
                }
            } catch (error) {
                testStats.testsFailed++;
                log('error', `Corrupted shark test failed: ${error.message}`);
            }
            
            updateStats();
            updateSystemStatus();
        };
        
        window.testSharkGeometry = function() {
            testStats.testsRun++;
            log('info', 'Testing shark geometry validation...');
            
            try {
                // Find shark entities in the scene
                let sharkCount = 0;
                if (window.debugGame?.entities) {
                    window.debugGame.entities.forEach(entity => {
                        if (entity.type === 'shark' && entity.mesh) {
                            sharkCount++;
                            entity.mesh.traverse(child => {
                                if (child.isMesh && child.geometry) {
                                    const result = window.debugGeometryValidator?.validateGeometry(
                                        child.geometry, 
                                        `shark-${entity.name}-${child.name}`
                                    );
                                    
                                    if (result && !result.isValid) {
                                        log('warn', `Shark geometry corruption detected: ${result.errors.join(', ')}`);
                                        testStats.corruptionsDetected++;
                                    }
                                }
                            });
                        }
                    });
                }
                
                if (sharkCount > 0) {
                    testStats.testsPassed++;
                    log('info', `Validated geometry for ${sharkCount} shark entities`);
                } else {
                    log('warn', 'No shark entities found in scene');
                    testStats.testsPassed++;
                }
            } catch (error) {
                testStats.testsFailed++;
                log('error', `Shark geometry test failed: ${error.message}`);
            }
            
            updateStats();
            updateSystemStatus();
        };
        
        window.spamSharkLoading = function() {
            testStats.testsRun++;
            log('info', 'Spam loading sharks to test memory/validation performance...');
            
            try {
                let loadCount = 0;
                const maxLoads = 5;
                
                const spamLoad = () => {
                    if (loadCount < maxLoads && window.debugGame) {
                        try {
                            // Simulate rapid shark entity creation
                            const testShark = {
                                name: `SpamShark${loadCount}`,
                                modelPath: 'assets/models/shark.glb',
                                position: { 
                                    x: Math.random() * 20 - 10, 
                                    y: Math.random() * 4, 
                                    z: -15 + Math.random() * 10 
                                },
                                health: 100,
                                points: 250
                            };
                            
                            loadCount++;
                            log('debug', `Spam load ${loadCount}/${maxLoads}: ${testShark.name}`);
                            
                            setTimeout(spamLoad, 100); // Load every 100ms
                        } catch (error) {
                            log('error', `Spam load ${loadCount} failed: ${error.message}`);
                        }
                    } else {
                        if (loadCount >= maxLoads) {
                            testStats.testsPassed++;
                            log('info', `Spam loading completed: ${loadCount} sharks`);
                        } else {
                            testStats.testsFailed++;
                            log('error', 'Spam loading failed: game not available');
                        }
                        updateStats();
                        updateSystemStatus();
                    }
                };
                
                spamLoad();
            } catch (error) {
                testStats.testsFailed++;
                log('error', `Spam shark loading failed: ${error.message}`);
                updateStats();
                updateSystemStatus();
            }
        };
        
        window.validateSharkModels = function() {
            testStats.testsRun++;
            log('info', 'Validating all shark models in the scene...');
            
            try {
                if (window.debugGame?.app) {
                    // Run scene validation specifically for sharks
                    window.debugGame.app.validateSceneGeometry();
                    
                    // Count shark-specific validations
                    let sharkValidations = 0;
                    window.debugGame.entities?.forEach(entity => {
                        if (entity.type === 'shark') {
                            sharkValidations++;
                        }
                    });
                    
                    testStats.testsPassed++;
                    log('info', `Validated ${sharkValidations} shark models`);
                } else {
                    testStats.testsFailed++;
                    log('error', 'App instance not available for shark validation');
                }
            } catch (error) {
                testStats.testsFailed++;
                log('error', `Shark model validation failed: ${error.message}`);
            }
            
            updateStats();
            updateSystemStatus();
        };
        
        // Initialize system status check
        updateSystemStatus();
        
        // Auto-refresh system status every 5 seconds
        setInterval(updateSystemStatus, 5000);
        
        log('info', 'WebGL Fix Testing Suite ready. Click buttons to run tests.');
    </script>
</body>
</html>
